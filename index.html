<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>sketch-006: land wave</title>
  <style>

    * {
      box-sizing: border-box;
    }


    html, body {
      margin:0;
      height:100%;
      width: 100%;
      font-family: sans-serif;
      font-size: 1em;
    }

    form, fieldset {
      padding: 0;
      margin: 0;
      border: 0;
    }

    canvas {
      margin: auto;
      cursor: crosshair;
    }

    .hide {
      display: none;
    }
  
    .container {
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: row;
      flex-wrap: no-wrap;
    }

    section, form {
      display: flex;
      flex-direction: column;
    }

    .container section {
      background-color: orange;
      flex: 1 0 15%;
      margin: auto;
    }

    #draw {
      flex: 1 0 70%;
      height: 100%;
    }

    #draw form {
      flex: 1 0 auto;
    }

    #draw form[name=img] {
      position: relative;
      flex: 1 0 90%;
      display: flex;
      /*position: relative;*/
    }

    .partout {
      height: 100%;
      margin: auto;
      background-color: green;
    }



  </style>
</head>
<body>

  <div class="container">

    <section id="output">
      <form name="output">
        <fieldset name="type">
          <legend>Output type</legend>
          <select>
            <option value="p5js">p5.js</option>
            <option value="array">array</option>
            <option value="json">JSON</opton>
          </select>
          <textarea name="output" disabled></textarea>
        </fieldset>
        <fieldset>
          <button type="button" name="undo" disabled>undo</button>
          <button type="button" name="redo"disabled>redo</button>
          <button type="button" name="clear">clear</button>
          <button type="button" name="copy" disabled>copy to clipboar</button>
          <button type="button" name="save" disabled>save</button>
        </fieldset>
      </form><!-- history -->
    </section><!--#output-->    

    <section id="draw">
      <form name="img">
        <div class="partout dashed-border">
          <div class="img-box">
            <div class="text">
              <h1>Hello!</h1>
              <p>choose file, make shapes, have a fun with p5.js</p>
              </div>
          </div><!--.img-box-->
        </div><!--.img-wrapper-->
      </form><!-- img -->
      <form name="coordinates">
        <fieldset>
          <legend>Coordinates/Colors</legend>
          <label>x: <input type="text" name="x" disabled></label>
          <label>y: <input type="text" name="y" disabled></label>
          <label>rgba: <input type="text" name="rgb" disabled></label>
        </fieldset>
      </form><!--coordinates-->
    </section><!--#draw-->

    <section id="toolbox">
        <form class="hide" name="map">
          <fieldset>
            <legend>Map</legend>
            <label>x:<input type="range" name="offsetX" value="0"></label>
            <label>y:<input type="range" name="offsetY" value="0"></label>
            <label>zoom:<input type="range" name="zoom" min="1" max="3" step="0.1" value="1"></label>
            <button type="button" name="reset">reset map</button>
          </fieldset>
        </form>
        <form name="toolbox">
          <fieldset name="file">
            <legend>File</legend>
            <input type="file" id="file">
          </fieldset>
          <fieldset name='canvas'>
            <button type='button' name='create'>new canvas</button>
            <button type='button' name='clear'>clear canvas</button>
            <button type="button" name="launch">launch</button>
          </fieldset>
          <fieldset name="nodes">
            <legend>Nodes: </legend>
            <label><input type="radio" name="node" value="line" checked>line</label>
            <label><input type="radio" name="node" value="quadratic">curve</label>
            <label><input type="checkbox" name="closePath">close path</label>
            <button type="button" name="new">new path</button>
          </fieldset>
          <fieldset name="show">
            <legend>show/hide<legend>
            <label><input type="checkbox" name="showImage" checked id="hello">image</label>
            <label><input type="checkbox" name="showPath" checked>path</label>
            <label><input type="checkbox" name="showNodes" checked>nodes</label>
          </fieldset>
          <fieldset name="customize">
            <legend>Custom colors:</legend>
            <fieldset>
              <legend>Nodes: </legend>
              <label>line: <input type="color" name="lineColor"></label>
              <label>quadratic: <input type="color" name="curveColor"></label> 
            </fieldset>
              <label>path: <input type="color" name="pathColor"></label>
              <label>fill: <input type="color" name="fillColor">
              </label>
          </fieldset>
        </form><!-- toolbox -->
      </section><!--#toolbar-->

  </div><!--.container-->


    <script>

    "use strict"



      let img, canvas, ctx ,draft, shadow;

      const $ = str => document.querySelector(str);
      const _ = str => $(`input[name=${str}]`);

      const is = str => _(str).checked;

      // const imgBox = $('.img-box');
      const imgBox = $('form[name=img]');
      const imgBtn = $('input[type=file]');

      const error = '<h1>Hey</h1><p>I\'m understand only img file types...</p>';     

      const who = (str) => [].filter.call(
        document.querySelectorAll(`input[name=${str}]`), e =>
          e.checked)[0].value;

      const getStyle = elm => window.getComputedStyle(elm);
      const getRect = (obj, elm) => obj.getBoundingClientRect(elm);

      const createCanvas = size => {
        let box = size;
        canvas = document.createElement('canvas');
        ctx = canvas.getContext('2d');
        draft = document.createElement('canvas');
        shadow = draft.getContext('2d');        
        canvas.width = box.w; canvas.height = box.h;
        draft.width = box.w; draft.height = box.h;
        removeChildren(imgBox);
        imgBox.appendChild(canvas);
        imgBox.appendChild(draft);
        draft.className = "hide";
        return {
          canvas,
          ctx
        };
      };

      const removeChildren = elm => {
        elm.innerHTML = '';
      }

      // const history = (u,r) => {
      //   let ab = (a,b) => {
      //     let x = a.arr.pop();
      //     if (!a.arr.length) { a.elm.disabled = true; }
      //     if (!b.arr.length) { b.elm.disabled = false; }
      //     b.arr.push(x);
      //     return x;
      //   };
      //   let clear = a => { a.arr =[]; a.flag = false; };
      //   return {
      //     add (elm) {
      //       u.arr.push(elm);
      //       r.arr = [];
      //       u.elm.disabled = false;
      //       r.elm.disabled = true;
      //     },
      //     undo () { return ab(u,r); },
      //     redo () { return ab(r,u); },
      //     reset () { clear(a); clear(b); }        
      //   };
      // };

      const size = elm => ({
        w: elm.clientWidth,
        h: elm.clientHeight
      });

      const btn = {
        create () {
          let obj = createCanvas(size(imgBox));
          canvas = obj.canvas;
          ctx = obj.ctx;
          listenCanvas();
        },
        launch () { timerFn(draw, 1000/60).start(); },
        // undo () {scene.undo()},
        // redo () {scene.redo()}
      };


      const anchorType = {
        move (pos) { return moveDot(pos) },
        line (pos) { return lineDot(pos) },
        quadratic (pos) { return quadraticDot(pos) }
      }

      // const copyOf = (a) => {
      //   return a.map(e => Object.assign(e,{})).slice();
      // }

      const screen = (state) => ({

        show () {console.log(state.arr) },

        drawRect () {
          state.arr.forEach(elm => elm.draw());
        },

        add (pos) {
          let elm;
          if (state.arr.length === 0) {
            elm = anchorType.move(pos);
          } else {
            pos.prev = state.last();
            elm = anchorType[who('node')](pos);
          }  
          state.arr.push(elm);
          console.log('add anchor: ', elm);
        },

        clear () {
          ctx.clearRect(0, 0, canvas.width, canvas.height);
        },

        drawPath () {
          ctx.beginPath();
          ctx.strokeStyle = _('pathColor').value;
          state.arr.forEach(elm => elm.path());
          if (_('closePath').checked) {
            ctx.fillStyle = _('fillColor').value;
            ctx.fill();
            ctx.closePath();
          }
          ctx.stroke();
        },

        isDot (target) {
          let search = state.arr.filter(elm => 
            target.x >= elm.box().left &&
            target.x <= elm.box().right && 
            target.y >= elm.box().top &&
            target.y <= elm.box().bottom
          );
          if (!search.length) {
            return false;
          } else {
            return { elm: search[0], method: 'moveDot' };
          }
        },

        isLine (target) {
          let len = state.arr.length;
          if (len > 0) {
            for (let i = 1; i < len; i++){
              if (state.arr[i].draggable) {
                shadow.lineWidth = 10;
                shadow.beginPath();
                shadow.moveTo(state.arr[i-1].x, state.arr[i-1].y);
                state.arr[i].path(shadow);
                if (shadow.isPointInStroke(target.x, target.y)) {
                  return { elm: state.arr[i], method: 'curve' };
                };
              };
            };
        };
        return false;
      }
    });

      // const len = (a,b) => Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow (a.y - b.y, 2));


const arr1 = [];
const arr2 = [];
      const scene = screen({
        arr:[],
        last () {
          return this.arr.slice(-1)[0];
        }
        // hist: history(
        //   { arr:arr1, elm: $('button[name=undo]') },
        //   { arr:arr2, elm: $('button[name=redo]') }
        // )
      });

      const rect = {

        color: '#ff0000',
        size: 10,
        draggable: false,
        box () {
          return {
            left: this.x - this.size/2,
            right: this.x + this.size/2,
            top: this.y - this.size/2,
            bottom: this.y + this.size/2
          }
        },
        draw () {
          let r = this.box();
          ctx.fillStyle = this.color;
          ctx.fillRect(r.left, r.top, this.size, this.size);
          return this;
        },
        moveDot (pos) {
          this.x = pos.x;
          this.y = pos.y;
        },
        // curve () {
            // hello, who are?
        // },
        path (context) {
          (context || ctx).lineTo(this.x, this.y);
        }
      };

      // first dot aka 'adam'
      const moveDot = pos => {
        return Object.assign(
          lineDot(pos),
          { path () {ctx.moveTo(this.x, this.y)} }
        );
      };

// pos = { x: x, y: y, prev: link to previus element }

      const quadraticDot = pos => {
        return Object.assign(
          lineDot(pos),
          { 
            px: pos.prev.x,
            py: pos.prev.y,
            color: 'green',
            draggable: true,
            curve (xy) { this.px = xy.x; this.py = xy.y; this.path(); },
            path (context) { (context || ctx).quadraticCurveTo( this.px, this.py, this.x, this.y)
            }
          }
        );
      };

      const lineDot = pos => {
        let state = { x: pos.x, y: pos.y };
        return Object.assign( Object.create(rect), state);
      };      

      const timerFn = (fn, ms) => {
        let id;     
        const start = () => { id = setInterval(fn, ms) };
        const stop = () => { clearInterval(id) };
        return { start: start, stop: stop } ;
      };


      const draw = () => {
        scene.clear();
        if (img && is('showImage')) {
          ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
        }
        if (is('showPath')) scene.drawPath();
        if (is('showNodes')) scene.drawRect();
      };

      document.body.addEventListener('click', e => {
        if (e.target.type === 'button') {
          btn[e.target.name]();
        }
      });


      const mouseXY = e => {
        let r = canvas.getBoundingClientRect(e);
        return {
          x: e.clientX - Math.floor(r.left),
          y: e.clientY - Math.floor(r.top)
        };
      };


      const pixelXY = pos => ctx.getImageData(pos.x, pos.y, 1,1).data;

      const listenCanvas = () => {

        let mouse;
        let drag = undefined;
        let mouseOverCanvas = false;

        const updateXYRGB = () => {
          _('x').value = mouse.x;
          _('y').value = mouse.y;
         _('rgb').value = pixelXY(mouse);
        };


        canvas.addEventListener('click', e => {
          if (drag) {
            drag = undefined;
          } else {
            scene.add(mouse);
          } 

        });

        canvas.addEventListener('mousedown', () => {
          drag = scene.isDot(mouse) || scene.isLine(mouse);
          // console.log(drag);
        });

        // canvas.addEventListener('mouseup', () => {

        // });

        canvas.addEventListener('mousemove', e => {
          mouse = mouseXY(e);
          if (drag) {
            drag.elm[drag.method](mouse);
          } else {
            if (scene.isDot(mouse) || scene.isLine(mouse)) {
              canvas.style.cursor = 'pointer';
            } else {
              canvas.style.cursor = 'crosshair';
            };
          };
          updateXYRGB();
        });

        canvas.addEventListener('mouseover', () => {
          mouseOverCanvas = true;
        });

        canvas.addEventListener('mouseout', () => {
          mouseOverCanvas = false;
        });
    }



////////////////////////////////////
// load-image
////////////////////////////////////


// listen event 'change' on imgBtn (input[type=file])
// onchange call handleFile

  imgBtn.addEventListener('change', handleFile);

// sendMsd :: string element --> null
// remove all from element 'to', make new 'div', add class 'error'
// add msg, put it inside element 'to'

  function sendMsg(msg, to) { 
    let err = document.createElement('div');
    err.className = 'error';
    err.innerHTML = msg;
    imgBox.innerHTML = '';
    imgBox.appendChild(err);
  }

// isImage :: string --> bool
// return true if filetype image

  function isImage(filetype) {
    return /^image/.test(filetype);
  }


//  getSize :: element --> object
//  return width and height of the element

  function getSize(elm) {
    if (elm.clientHeight){
      return {
        w: elm.clientWidth,
        h: elm.clientHeight
      }
    } else {
      return {
        w: elm.width,
        h: elm.height
      }
    }
  }

// fitSize object --> object --> object
// resize 'a' to fit in 'b'

  function fitSize(a, b) {
    let rate = a.w / a.h;
    if (a.w > b.w) {
      a.h -= (a.w - b.w) / rate;
    } else {
      a.h += (b.w - a.w) / rate;
    }
    a.w = b.w;  
    if (a.h > b.h) {
      a.w -= (a.h - b.h) * rate;
      a.h -= a.h - b.h;
    } 
    a.w = Math.ceil(a.w);
    a.h = Math.ceil(a.h);    
    return a;
  
  }

// handleFile event --> img
// if event 'change' on input[type=file]
// if filetype image make new image and add to canvas

  function handleFile() {   
    let file = this.files[0];
    if ( !isImage(file.type) ) {
      sendMsg(error, imgBox);
    } else {
      img = new Image();
      img.src = window.URL.createObjectURL(file);     
      img.onload = function(){
        window.URL.revokeObjectURL(this.src);
        drawImg(this); // when img loaded... put it in canvas
      }
    }
  }

  function drawImg(img) {
    let size = fitSize(getSize(img),getSize(imgBox));
    createCanvas(size);
    ctx.drawImage(img, 0, 0, size.w, size.h);
    document.forms.map.style.display = "block";
    setRange('input[name=offsetX]', size.w);
    setRange('input[name=offsetY]', size.h);
    listenCanvas();
  }

    function setRange(str, value){
      let elm = document.querySelector(str);
      elm.min = -value;
      elm.max = value;
    }

    </script>


  </body>
</html>