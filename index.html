<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>shaper</title>
  <style>

    * {
      box-sizing: border-box;
    }


    html, body {
      margin: 0;
      padding: 0;
      height:100%;
      width: 100%;
      font-family: sans-serif;
      font-size: 1em;
    }


    form, fieldset {
      padding: 0;
      margin: 0;
      border: 0;
    }

    canvas {
      margin: auto;
      cursor: crosshair;
    }

    .hide {
      display: none;
    }
  
    .container {
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: row;
      flex-wrap: no-wrap;
    }

    section {
      padding: 0 1%;
      margin: auto;
      height: 100%;
      justify-content: center;
    }


    section, form {
      display: flex;
      flex-direction: column;
    }

    .container section {
      flex: 1 0 15%;
      margin: auto;
    }

    #draw {
      flex: 1 0 70%;
      height: 100%;
      padding: 0;
    }

    #draw form {
      flex: 1 0 auto;
    }

    #draw form[name=img] {
      position: relative;
      flex: 1 0 90%;
      display: flex;
      /*position: relative;*/
    }

    form[name=output] {
      /*flex: 1 0 50%;*/
    }

    .partout {
      height: 100%;
      margin: auto;
      background-color: green;
    }

    label {
      display: block;
    }

/*    form[name=coordinates] fieldset{
      width: 100%;
      display: flex;
      flex-direction: row;
      justify-content: space-around;
    }*/

    fieldset {
      border: 1px solid rgba(0, 0, 0, .3);
      padding: 10px;
      margin: 0;
    }

    legend {
      color: rgba(0,0,0,.7);
      text-transform: lowercase;
      font-size: .6em;
    }

    label {
      font-size: .6em;
    }
    
    .inputfile {
      width: 0.1px;
      height: 0.1px;
      opacity: 0;
      overflow: hidden;
      position: absolute;
      z-index: -1;
    }

    .inputfile + label {
      font-size: .4em;
      padding: 2px 6px 3px 2px;
      color: black;
      border: 1px solid rgb(192, 192, 192);
      border-radius: 10px;
      background-color: white;
      text-align: center;
      /*display: inline-block;*/
    }

    .inputfile + label, button, input, label {
      cursor: pointer;
    }

    input[type=range] {
      width: 100%; 
      padding: 0;
      margin: 0;
    }

    fieldset[name=colors]{
      display: flex;
      flex-direction: row;
    }

    fieldset[name="textarea"] {
      flex: 1 0 50%;
    }

    textarea {
      display: block;
      /*resize: none;*/
      width: 100%;
      height: auto;
      outline: none;
      resize: none;
    }
/*    .msg {
      position: fixed;
    }*/

    fieldset[name=coordinates] input {
      /*border: 0;*/
      text-align: center;
      /*width: 100%;*/
    }

/*   input[type=color]{
      width: 0.1px;
      height: 0.1px;
      opacity: 0;
      overflow: hidden;
      position: absolute;
      z-index: -1;
    }*/

  .color {
    height: 5px;
  }

    

  </style>
</head>
<body>

  <div class="container">

    <section id="output">
      <form name="input">
       <fieldset name="file">
            <legend>file: </legend>
              <input type="file" name="file" id="file" class="inputfile" />
              <label for="file">Choose a file</label>
          </fieldset>
          <fieldset name='canvas'>
            <legend>canvas:</legend>
            <button type='button' name='create'>new canvas</button>
            <button type='button' name='clear'>clear canvas</button>
            <button type="button" name="launch">launch</button>
          </fieldset>
          <fieldset name="show">
            <legend>show/hide</legend>
            <label><input type="checkbox" name="showImage" checked id="hello">image</label>
            <label><input type="checkbox" name="showShapes" checked>shapes</label>
            <label><input type="checkbox" name="showCurrent" checked>current</label>
            <label><input type="checkbox" name="showNodes" checked>nodes</label>
          </fieldset>
      </form>
      <form name="output">
        <fieldset name="type">
          <legend>output:</legend>
          <select>
            <option value="p5js">p5.js</option>
            <option value="array">array</option>
            <option value="json">JSON</option>
          </select>
          <button type="button" name="copy" disabled>copy</button>
          <button type="button" name="save" disabled>save</button>
        </fieldset>
        <fieldset name="textarea">
          <legend>your code:</legend>
          <textarea name="text" rows="10" readonly placeholder="// you code here"></textarea>
        </fieldset>
      </form><!-- history -->
    </section><!--#output-->    

    <section id="draw">
      <form name="img">
        <div class="partout dashed-border">
          <div class="img-box">
            <div class="text">
              <h1>Hello!</h1>
              <p>choose file, make shapes, have a fun with p5.js</p>
              </div>
          </div><!--.img-box-->
        </div><!--.img-wrapper-->
      </form><!-- img -->
    </section><!--#draw-->

    <section id="toolbox">
      <form name="toolbox">
        <fieldset name="coordinates">
          <legend>Size/Coordinates/Color:</legend>
          <input type="text" name="size" value="w: , h:" readonly disabled/>
          <input type="text" name="xy" value="x: , y:" readonly disabled/>
          <input type="text" name="rgb" value="rgb:" readonly disabled/>
        </fieldset>

          <fieldset name="map">
            <legend>Map</legend>
            <label>x offset:<span></span><input type="range" name="offsetX" value="0"></label>
            <label>y offset:<span></span><input type="range" name="offsetY" value="0"></label>
            <label>zoom:<span></span><input type="range" name="zoom" min="1" max="3" step="0.1" value="1"></label>
            <button type="button" name="reset">reset map</button>
          </fieldset>

          <fieldset name="nodes">
            <legend>Nodes: </legend>
            <label><input type="radio" name="node" value="line" checked />line</label>
            <label><input type="radio" name="node" value="quadratic" />curve</label>
          </fieldset>
          <fieldset name="path">
            <legend>path:</legend>
            <button type="button" name="newPath">new path</button>
            <button type="button" name="delPath">del path</button>
            <label>fixed path:<input type="checkbox" name="fixedCurrent" checked/></label>
          </fieldset>
        </form><!-- toolbox -->
        <form name="customize">
            <fieldset name="customize">
              <legend>tuning shape:</legend>
                <label><input type="checkbox" name="closePath" />close path</label>
                <fieldset name="colors">
                  <legend>colors: </legend>
                  <label>fill: <input type="color" name="fillColor" id="fillColor" value="#AFCAF6"></label>
                  <label>path: <input type="color" name="pathColor" id="pathColor"  value="#FEF95D"></label>
                </fieldset>
                <fieldset>
                  <legend>width:</legend>
                  <label>line: <span></span><input type="range" name="lineWidth" min="0" max="10" value="1" step=".5" /></label>
                </fieldset>
                <fieldset>
                  <legend>opacity:</legend>
                  <label>shape: <span></span><input type="range" name="shapeOpacity" min="0" max="1" value="1" step=".1"></label> 
                  <label>line: <span></span><input type="range" name="lineOpacity" min="0" max="1" value="1" step=".1"></label>   
                </fieldset>
            </fieldset>
          </form>
      </section><!--#toolbox-->

  </div><!--.container-->


    <script>

    "use strict"



      let img, canvas, ctx, draft, shadow;

      const $ = str => document.querySelector(str);
      const _ = str => $(`input[name=${str}]`);

      const is = str => _(str).checked;

      // const imgBox = $('.img-box');
      const imgBox = $('form[name=img]');
      // const imgBox = $('body');
      const imgBtn = $('input[type=file]');

      const error = '<h1>Hey</h1><p>I\'m understand only img file types...</p>';     

      const who = (str) => [].filter.call(
        document.querySelectorAll(`input[name=${str}]`), e =>
          e.checked)[0].value;

      const getStyle = elm => window.getComputedStyle(elm);
      const getRect = (obj, elm) => obj.getBoundingClientRect(elm);

      const createCanvas = size => {
        let box = size;
        canvas = document.createElement('canvas');
        ctx = canvas.getContext('2d');
        draft = document.createElement('canvas');
        shadow = draft.getContext('2d');        
        canvas.width = box.w; canvas.height = box.h;
        draft.width = box.w; draft.height = box.h;
        removeChildren(imgBox);
        imgBox.appendChild(canvas);
        imgBox.appendChild(draft);
        draft.className = "hide";
        _('size').value = `w: ${canvas.width}, h: ${canvas.height}`;
        return {
          canvas,
          ctx
        };
      };

      const removeChildren = elm => {
        elm.innerHTML = '';
      }

      const size = elm => ({
        w: elm.clientWidth,
        h: elm.clientHeight
      });


      const initial = {
        offsetX: 0,
        offsetY: 0,
        zoom: 1
      };

      const btn = {

        create () {
          let obj = createCanvas(size(imgBox));
          canvas = obj.canvas;
          ctx = obj.ctx;
          listenCanvas();
        },
        reset () { 
          Object.keys(initial).forEach( e => {
            _(e).value = initial[e];
            updateUI({target: _(e)});
          });
        },
        launch () { timerFn(draw, 1000/60).start(); },
        // undo () {scene.undo()},
        // redo () {scene.redo()}
        newPath() { scene.newPath(); },
        delPath() { scene.delPath(); }
      };

      const mapping = () => ({
        x: _('offsetX').value * _('zoom').value,
        y: _('offsetY').value * _('zoom').value,
        z: _('zoom').value
      });

      const anchorType = {
        move (pos) { return moveDot(pos) },
        line (pos) { return lineDot(pos) },
        quadratic (pos) { return quadraticDot(pos) }
      }

      const toRGB = (hex) => {
        let i = hex[0] === '#' && -1 || -2;
        return () => {
          i += 2;
          return parseInt(hex.slice(i, i + 2), 16);
        }
      };


      const pathMethod = {

        // update (colors) {
          
        // },

        show () {console.log(this.arr) },

        drawRect () {
          this.arr.forEach(elm => elm.draw());
        },

        add (pos) {
          let elm;
          if (this.arr.length === 0) {
            elm = anchorType.move(pos);
          } else {
            pos.prev = this.last();
            elm = anchorType[who('node')](pos);
          }  
          this.arr.push(elm);
          console.log('add anchor: ', elm);
        },

        drawPath () {
          let ff = toRGB(this.pathColor);
          let aa = toRGB(this.fillColor);
          ctx.beginPath();
          ctx.strokeStyle = `rgba(${ff()}, ${ff()}, ${ff()}, ${this.lineOpacity})`;
          ctx.lineWidth = this.lineWidth;
          this.arr.forEach(elm => elm.path());
          if (this.closePath) {
            ctx.fillStyle = `rgba(${aa()}, ${aa()}, ${aa()}, ${this.shapeOpacity})`;
            ctx.fill();
            ctx.closePath();
          }
          ctx.stroke();
        },

        shadowPath (t) {
          shadow.lineWidth = 5;
          shadow.beginPath();
          this.arr.forEach(e => e.path(shadow));
          if (shadow.isPointInStroke(t.x, t.y)) {
            return this;
          } else {
            return false;
          }
        },

        delNode (elm) {
          this.arr.splice(this.arr.indexOf(elm),1);
        },

        isDot (target) {
          let search = this.arr.filter(elm => target.x >= elm.box().left
            && target.x <= elm.box().right && target.y >= elm.box().top 
            && target.y <= elm.box().bottom
          );
          if (!search.length) {
            return false;
          } else {
            return { path: this, elm: search[0], method: 'moveDot' };
          }
        },

        isLine (target, flag) {
          flag = flag || true;
          let len = this.arr.length;
          if (len > 0) {
            for (let i = 1; i < len; i++){
              if (this.arr[i].draggable) {
                shadow.lineWidth = 5;
                shadow.beginPath();
                shadow.moveTo(this.arr[i-1].x, this.arr[i-1].y);
                this.arr[i].path(shadow);
                if (shadow.isPointInStroke(target.x, target.y)) {
                  return { path: this, elm: this.arr[i], method: 'curve' };
                };
              };
            };
        };
        return false;
      }
    };

    const test222 =[]; /////////


    const pathTuning = () => ({
      fillColor: _('fillColor').value, 
      lineWidth: _('lineWidth').value,
      pathColor: _('pathColor').value,
      lineWidth: _('lineWidth').value,
      closePath: is('closePath'),
      shapeOpacity: _('shapeOpacity').value,
      lineOpacity: _('lineOpacity').value
    });

    const scrim = (state) => {
      let arr = [];
      let current = undefined;
      // let overmouse = undefined;

      let method = {


        update (e) { current[e.target.name] = e.target.value; console.log(e.target.value)},
        
        clear () { ctx.clearRect(0,0, canvas.width, canvas.height)},
        
        newPath () { arr.push(shape({arr:[]}));
          current=arr.slice(-1)[0];},  // push in arr new path object
        
        add (elm) { current.add(elm); },
        
        drawPath () { 
          if (is('showShapes')) {
            arr.forEach(e => e.drawPath());
          } else {
            current.drawPath();
          };
        },

        // turn (elm) { current = elm.path },

        delPath () { 
          arr.splice(arr.indexOf(current),1);
          if (!arr.length) {
            btn.newPath();
          } else {
            current = arr.slice(-1)[0];
          };
        },

        drawRect () { current.drawRect() },

        isDot (t) { return current.isDot(t);

        },
        isLine (t) { return current.isLine(t)

        },
        overmouse (t) {
          if (!current.arr.length) {
            return false;
          } else {
            let search = arr.filter(e => e.shadowPath(t))[0];
              if (search) {
                current = search;
                return current;
              } else {
                return false;
              }
            };
        },

        show() {console.log(current)},
        get () {return current}
      };

      return  method;
    }


    const customArray = {
      head () { return this.arr[0]},
      tail () { return this.arr.slice(1)},
      init () { return this.arr.slice(0, -1)},
      last () { return this.arr.slice(-1)[0]}
    };


    const shape = (state) => { //after all remove state...
      return Object.assign(
        Object.create(Object.assign(
          Object.create(customArray), pathMethod)),
        { arr: state.arr || []},
        pathTuning()
        );
    };

      const scene = scrim();
      scene.newPath({arr:[]});
      // const scene = shape({arr: []});

      const node = {
        color: '#ff0000',
        size: 5,
        draggable: false
      };

      const nodeMethod = {

        box () {
          let accuracy = 5 / mapping().z;
          return {
            left: this.x - this.size/2 + accuracy,
            right: this.x + this.size/2 + accuracy,
            top: this.y - this.size/2 + accuracy,
            bottom: this.y + this.size/2 + accuracy 
          }
        },

        draw () {
          let r = this.box();
          ctx.fillStyle = this.color;
          ctx.fillRect(r.left, r.top, this.size, this.size);
          return this;
        },

        moveDot (pos) {
          this.x = pos.x;
          this.y = pos.y;
        },
        // curve () {
            // hello, who are?
        // },
        path (context) {
          (context || ctx).lineTo(this.x, this.y);
        }
      };


      const moveDot = pos => {
        return Object.assign(
          lineDot(pos),
          { path (context) { (context || ctx).moveTo(this.x, this.y)} }
        );
      };


      const curveMethod = {
        curve (xy) { this.px = xy.x; this.py = xy.y; this.path(); },
        path (context) {
          (context || ctx).quadraticCurveTo( this.px, this.py, this.x, this.y)} 
      };



      const curveRect = (pos) => {
        return Object.assign(
          Object.create(lineDot(pos)),
            { color: 'green', draggable: true},
            curveMethod
          );
      };

      const quadraticDot = pos => {
        let state = { px: pos.prev.x, py: pos.prev.y };
        return Object.assign(Object.create(curveRect(pos)), state);
      }

      const lineDot = pos => {
        let state = { x: pos.x, y: pos.y };
        return Object.assign(Object.create(
          Object.assign(Object.create(node), nodeMethod)),
          state);
      };      

      const timerFn = (fn, ms) => {
        let id;     
        const start = () => { id = setInterval(fn, ms) };
        const stop = () => { clearInterval(id) };
        return { start: start, stop: stop } ;
      };


      const draw = () => {
        let map = mapping();
        scene.clear();
        ctx.setTransform(map.z, 0, 0, map.z, map.x, map.y);
        if (img && is('showImage')) {
          ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
        }
        if (is('showCurrent')) scene.drawPath(map);
        if (is('showNodes')) scene.drawRect();
      };

      document.body.addEventListener('click', e => {
        if (e.target.type === 'button') {
          btn[e.target.name]();
        };
      });

      // document.body.addEventListener('mouseDown', e => {
      //   if (e.target.name === 'color') {
      //     $(`#${e.target.name}`).style.backgroundColor = e.target.value;
      //   };
      // });

      const updateUI = e => {
        if (e.target.previousSibling) {
          e.target.previousSibling.innerHTML = ` ${e.target.value}`;
        }
      }

      document.body.addEventListener('input', updateUI);
      document.forms.customize.addEventListener('input', scene.update);
      document.forms.customize.addEventListener('change', e => {
        if (e.target.name === 'closePath') scene.get().closePath = e.target.checked;
      });

      const mouseXY = e => {
        let r = canvas.getBoundingClientRect(e);
        let map = mapping();
        return {
          x: (e.clientX - Math.floor(r.left))/map.z - map.x/map.z,
          y: (e.clientY - Math.floor(r.top))/map.z - map.y/map.z
        };
      };

      const pixelXY = pos => ctx.getImageData(pos.x, pos.y, 1, 1).data;

      const listenCanvas = () => {

        let mouse;
        let drag = undefined;
        let mouseOverCanvas = false;
        let mouseOverLine = undefined;
        let mouseOverElm = undefined;

        const updateXYRGB = () => {
          _('xy').value = `x: ${mouse.x}, y: ${mouse.y}`;
         _('rgb').value = `rgb: ${pixelXY(mouse).slice(-3)}`;
        };


        canvas.addEventListener('click', e => {

          if (e.shiftKey && mouseOverLine) {
            scene.delPath(mouseOverLine);
            return null;
          }

          if (e.altKey && drag.method === "moveDot") {
            drag.path.delNode(drag.elm);
            drag = undefined;
            return null;
          }
          if (drag) {
            drag = undefined;
          } else {
            scene.add(mouse);
          } 

        });

        canvas.addEventListener('mousedown', (e) => {
          drag = mouseOverElm;
            // if (drag) scene.turn(drag.path);
          // console.log(drag);
        });

        // canvas.addEventListener('mouseup', (e) => {

        // });

        canvas.addEventListener('mousemove', e => {
          mouse = mouseXY(e);
          if (drag) {
            drag.elm[drag.method](mouse);
          } else {
            if (!is('fixedCurrent')) {
              mouseOverLine = scene.overmouse(mouse);
            }
            mouseOverElm = scene.isDot(mouse) || scene.isLine(mouse)
            if (mouseOverElm) {
              canvas.style.cursor = 'pointer';
            } else {
              canvas.style.cursor = 'crosshair';
            };
          };
          updateXYRGB();
        });

        canvas.addEventListener('mouseover', () => {
          mouseOverCanvas = true;
        });

        canvas.addEventListener('mouseout', () => {
          mouseOverCanvas = false;
        });
    }



////////////////////////////////////
// load-image
////////////////////////////////////


// listen event 'change' on imgBtn (input[type=file])
// onchange call handleFile

  imgBtn.addEventListener('change', handleFile);

// sendMsd :: string element --> null
// remove all from element 'to', make new 'div', add class 'error'
// add msg, put it inside element 'to'

  function sendMsg(msg, to) { 
    let err = document.createElement('div');
    err.className = 'error';
    err.innerHTML = msg;
    imgBox.innerHTML = '';
    imgBox.appendChild(err);
  }

// isImage :: string --> bool
// return true if filetype image

  function isImage(filetype) {
    return /^image/.test(filetype);
  }


//  getSize :: element --> object
//  return width and height of the element

  function getSize(elm) {
    if (elm.clientHeight){
      return {
        w: elm.clientWidth,
        h: elm.clientHeight
      }
    } else {
      return {
        w: elm.width,
        h: elm.height
      }
    }
  }

// fitSize object --> object --> object
// resize 'a' to fit in 'b'

  function fitSize(a, b) {
    let rate = a.w / a.h;
    if (a.w > b.w) {
      a.h -= (a.w - b.w) / rate;
    } else {
      a.h += (b.w - a.w) / rate;
    }
    a.w = b.w;  
    if (a.h > b.h) {
      a.w -= (a.h - b.h) * rate;
      a.h -= a.h - b.h;
    } 
    a.w = Math.floor(a.w);
    a.h = Math.floor(a.h);    
    return a;
  
  }

// handleFile event --> img
// if event 'change' on input[type=file]
// if filetype image make new image and add to canvas

  function handleFile() {   
    let file = this.files[0];
    if ( !isImage(file.type) ) {
      sendMsg(error, imgBox);
    } else {
      img = new Image();
      img.src = window.URL.createObjectURL(file);     
      img.onload = function(){
        window.URL.revokeObjectURL(this.src);
        drawImg(this); // when img loaded... put it in canvas
      }
    }
  }

  function drawImg(img) {
    let size = fitSize(getSize(img),getSize(imgBox));
    createCanvas(size);
    ctx.drawImage(img, 0, 0, size.w, size.h);
    setRange('input[name=offsetX]', size.w);
    setRange('input[name=offsetY]', size.h);
    listenCanvas();
  }

    function setRange(str, value){
      let elm = document.querySelector(str);
      elm.min = -value;
      elm.max = value;
    }


      // const history = (u,r) => {
      //   let ab = (a,b) => {
      //     let x = a.arr.pop();
      //     if (!a.arr.length) { a.elm.disabled = true; }
      //     if (!b.arr.length) { b.elm.disabled = false; }
      //     b.arr.push(x);
      //     return x;
      //   };
      //   let clear = a => { a.arr =[]; a.flag = false; };
      //   return {
      //     add (elm) {
      //       u.arr.push(elm);
      //       r.arr = [];
      //       u.elm.disabled = false;
      //       r.elm.disabled = true;
      //     },
      //     undo () { return ab(u,r); },
      //     redo () { return ab(r,u); },
      //     reset () { clear(a); clear(b); }        
      //   };
      // };

      console.log('hello, there... \nif you have questions. \nyou can write me at\nandrei.fzto {meow} gmail.com')
    </script>


  </body>
</html>



