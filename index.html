<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>sketch-006: land wave</title>
  <style>

    * {
      box-sizing: border-box;
    }

    canvas {
      cursor: crosshair;
    }

    html, body {
      margin:0;
      height:100%;
      font-family: sans-serif;
      font-size: 1em;
    }

    form, fieldset {
      padding: 0;
      margin: 0;
      border: 0;
    }

    canvas {
      position: absolute;
      left:0;
      top:0;
      z-index: 1;
    }

    .shadow {
      z-index: 0;
    }

    fieldset {
      /*border-top: 5px solid green;*/
      /*border: 1px solid black;*/
    }

    textarea {
      height: 50%;
      width: 100%;
    }

    .container {
      height: 100%;
      display:flex;
      flex-wrap: nowrap;
      align-items: center;
      /*background-color: rgb(254, 204, 100);*/
    }

    .max-height {
      height:100%;
    }

    .flex {
      display: flex;
    }

    .col {
      flex-direction: column;
    }

    .row {
      flex-direction: row;
    }

    .alg-center {
      justify-content: center;
    }

    legend {
      font-size:.5em;
      /*text-align: center;*/
    }

    .center, .text, .error, img {
      position:absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
    }

    .img-box {
      height: 100%;
      width: 100%;
      position: relative;
    }

    .img-box h1 {
      padding-left: 10%;
    }

    .img-box p {
      padding-left: 10%;
    }

    button.current {
      color: red;
    }
  
    section {
      padding: 0 2%;
      /*background-color: green;*/
      height:100%;
      display:flex;
      flex-direction:column;
      justify-content: center;
    }

    #output, #toolbox {
      flex: 1 0 25%;
    }

    h1, p {
      padding: 0;
      margin: 0;
    }

    #draw {
      flex: 1 0 50%;
      padding: 2% 0;
    }

    #toolbox label {
      font-size: 0.5em;
    }

    .partout {
      position: relative;
      height: 100%;
      padding: 1%;
      /*background-color: orange;*/
    }

    .dashed-border {
      border: 5px dashed lightgrey;
    }

    .radio label {
      font-size:0.5em;
    }
/*for test*/
    .green {
      background-color: green;
    }

    .hide {
      display: none;
    }

    label {
      display: box;
    }

    #zoom {
      width: 100%;
    }


  </style>
</head>
<body>

  <div class="container">

    <section id="output">
      <form name="output">
        <fieldset name="type">
          <legend>Output type</legend>
          <select>
            <option value="p5js">p5.js</option>
            <option value="array">array</option>
            <option value="json">JSON</opton>
            </select>
          <textarea name="output" disabled></textarea>
        </fieldset>
      </form><!-- output -->
      <form name="history" id='hist'>
        <button type="button" name="undo" disabled>undo</button>
        <button type="button" name="redo"disabled>redo</button>
        <button type="button" name="clear">clear</button>
        <button type="button" name="copy" disabled>copy to clipboar</button>
        <button type="button" name="save" disabled>save</button>
      </form><!-- history -->
    </section><!--#output-->

    <section id="draw">
      <div class="partout dashed-border">
        <div class="img-box">
          <div class="text">
            <h1>Hello!</h1>
            <p>choose file, make shapes, have a fun with p5.js</p>
            </div>
        </div><!--.img-box-->
      </div><!--.img-wrapper-->
      <form name="coordinates">
        <fieldset>
          <legend>Coordinates/Colors</legend>
                <label>x: <input type="text" name="x" disabled></label>
                <label>y: <input type="text" name="y" disabled></label>
                <label>rgb: <input type="text" name="rgb" disabled></label>
            </fieldset>
          </form><!--coordinates-->
    </section><!--#draw-->


    <section id="toolbox">
        <form class="hide" name="map">
          <fieldset>
            <legend>Map</legend>
            <label>x:<input type="range" name="offsetX" value="0"></label>
            <label>y:<input type="range" name="offsetY" value="0"></label>
            <label>zoom:<input type="range" name="zoom" min="1" max="3" step="0.1" value="1"></label>
            <button type="button" name="reset">reset map</button>
          </fieldset>
        </form>
        <form name="toolbox">
          <fieldset name="file">
            <legend>File</legend>
            <input type="file" id="file">
            <button type='button' name='create'>create canvas</button>
            <button type="button" name="launch">launch</button>
          </fieldset>
          <fieldset name="primitives">
            <legend>2D primitives</legend>
            <label><input type="radio" name="shape" value="triange">triangle</label>
            <label><input type="radio" name="shape" value="ellipse">ellipse</label>
            <label><input type="radio" name="shape" value="line">line</label>
            <label><input type="radio" name="shape" value="curve">curve</label>
            <label><input type="radio" name="shape" value="bezier">bezier</label>
            <label><input type="radio" name="shape" value="arc">arc</label>
          </fieldset>
          <fieldset name="shapes">
            <legend>Shape</legend>
            <label><input type="radio" name="path" value="line" checked>line</label>
            <label><input type="radio" name="path" value="bezier">bezier</label>
            <label><input type="radio" name="path" value="quadratic">curve</label>
            <label><input type="checkbox" name="closePath">close path</label>
            <button type="button" name="new">new path</button>
          </fieldset>
        </form><!--toolbar-->
        <form>
        <fieldset>
          <legend>show/hide<legend>
          <label><input type="checkbox" name="showImage" checked id="hello">image</label>
          <label><input type="checkbox" name="showPath" checked>shapes</label>
          <label><input type="checkbox" name="showDots" checked>dots</label>
        </fieldset>
      </form>
      </seciton><!--#toolbar-->
    </div><!--.container-->

    <script>

    "use strict"



      let canvas, ctx;
      let draft, shadow;
      let arr = []; ///// -->scene
      const $ = str => document.querySelector(str);
      const _ = str => $(`input[name=${str}]`);
      const imgBox = $('.img-box');
      const who = (str) => [].filter.call(
        document.querySelectorAll(`input[name=${str}]`), e =>
          e.checked)[0].value;
      const is = str => _(str).checked;      

      const createCanvas = elm => {
        let box = size(elm);
        canvas = document.createElement('canvas');
        ctx = canvas.getContext('2d');
        draft = document.createElement('canvas');
        shadow = draft.getContext('2d');        
        canvas.width = box.w; canvas.height = box.h;
        draft.width = box.w; draft.height = box.h;
        removeChildren(elm);
        elm.appendChild(canvas);
        elm.appendChild(draft);
        draft.className = "shadow";
        return {
          canvas,
          ctx
        };
      }

      const removeChildren = elm => {
        elm.innerHTML = '';
      }

      const history = (u,r) => {
        let ab = (a,b) => {
          let x = a.arr.pop();
          if (!a.arr.length) { a.elm.disabled = true; }
          if (!b.arr.length) { b.elm.disabled = false; }
          b.arr.push(x);
          return x;
        };
        let clear = a => { a.arr =[]; a.flag = false; };
        return {
          add (elm) {
            u.arr.push(elm);
            r.arr = [];
            u.elm.disabled = false;
            r.elm.disabled = true;
          },
          undo () { return ab(u,r); },
          redo () { return ab(r,u); },
          reset () { clear(a); clear(b); }        
        };
      };


      const life = history(
        { arr:[], elm: $('button[name=undo]') },
        { arr:[], elm: $('button[name=redo]') }
      );

      const size = elm => ({
        w: elm.clientWidth,
        h: elm.clientHeight
      });

      const btn = {
        create () {
          let obj = createCanvas($('.partout'));
          canvas = obj.canvas;
          ctx = obj.ctx;
          listenCanvas();
        },
        launch () { timerFn(draw, 1000/60).start(); },
        undo () {scene.undo()},
        redo () {scene.redo()}
      };


      const anchorType = {
        move (pos) { return moveDot(pos) },
        line (pos) { return lineDot(pos) },
        quadratic (pos) { return quadraticDot(pos) }
      }

      const copyOf = (a) => {
        return a.map(e => Object.create(e)).slice();
      }

      const screen = (state) => ({

        undo () { state.arr = copyOf(state.hist.undo()); console.log('u', state.arr)},
        redo () { state.arr = copyOf(state.hist.redo()); console.log('r', state.arr)},
        save () { let tmp = copyOf(state.arr); console.log('a',tmp); state.hist.add(tmp); },
        show () {console.log(state.arr) },

        drawRect () {
          state.arr.forEach(elm => elm.draw());
        },

        add (pos) {
          let elm;
          if (state.arr.length === 0) {
            elm = anchorType.move(pos);
          } else {
            pos.prev = state.last();
            elm = anchorType[who('path')](pos);
          }  
          state.arr.push(elm);
          console.log('add anchor: ', elm);
        },

        clear (elm) {
          elm.clearRect(0, 0, canvas.width, canvas.height);
        },

        drawPath () {
          ctx.beginPath();
          ctx.strokeStyle = 'black';
          state.arr.forEach(elm => elm.path());
          if (_('closePath').checked) {
            ctx.closePath();
          }
          ctx.stroke();
        },

        isDot (target) {
          let search = state.arr.filter(elm => 
            target.x >= elm.box().left &&
            target.x <= elm.box().right && 
            target.y >= elm.box().top &&
            target.y <= elm.box().bottom
          );
          if (!search.length) {
            return false;
          } else {
            return { elm: search[0], method: 'moveDot' };
          }
        },

        isLine (target) {
          let len = state.arr.length;
          if (len > 0) {
            for (let i = 1; i < len; i++){
              if (state.arr[i].draggable) {
                shadow.lineWidth = 10;
                shadow.beginPath();
                shadow.moveTo(state.arr[i-1].x, state.arr[i-1].y);
                state.arr[i].path(shadow);
                if (shadow.isPointInStroke(target.x, target.y)) {
                  return { elm: state.arr[i], method: 'curve' };
                };
              };
            };
        };
        return false;
      }
    });

      // const len = (a,b) => Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow (a.y - b.y, 2));


const arr1 = [];
const arr2 = [];
      const scene = screen({
        arr:arr,
        last () {
          return arr.slice(-1)[0];
        },
        hist: history(
          { arr:arr1, elm: $('button[name=undo]') },
          { arr:arr2, elm: $('button[name=redo]') }
        )
      });

      const rect = {

        color: '#ff0000',
        size: 10,
        draggable: false,
        box () {
          return {
            left: this.x - this.size/2,
            right: this.x + this.size/2,
            top: this.y - this.size/2,
            bottom: this.y + this.size/2
          }
        },
        draw () {
          let r = this.box();
          ctx.fillStyle = this.color;
          ctx.fillRect(r.left, r.top, this.size, this.size);
          return this;
        },
        moveDot (pos) {
          this.x = pos.x;
          this.y = pos.y;
        },
        // curve () {
            // hello, who are?
        // },
        path (context) {
          (context || ctx).lineTo(this.x, this.y);
        }
      };

      // first dot aka 'adam'
      const moveDot = pos => {
        return Object.assign(
          lineDot(pos),
          {path () {ctx.moveTo(this.x, this.y)}}
        );
      };

// pos = { x: x, y: y, prev: link to previus element }

      const quadraticDot = pos => {
        return Object.assign(
          lineDot(pos),
          { 
            px: pos.prev.x,
            py: pos.prev.y,
            color: 'green',
            draggable: true,
            curve (xy) { this.px = xy.x; this.py = xy.y; this.path(); },
            path (context) { (context || ctx).quadraticCurveTo( this.px, this.py, this.x, this.y)
            }
          }
        );
      };

      const lineDot = pos => {
        let state = { x: pos.x, y: pos.y };
        return Object.assign( Object.create(rect), state);
      };      

      const timerFn = (fn, ms) => {
        let id;     
        const start = () => { id = setInterval(fn, ms) };
        const stop = () => { clearInterval(id) };
        return { start: start, stop: stop } ;
      };


      const draw = () => {
        scene.clear(ctx);
        if (is('showPath')) scene.drawPath();
        if (is('showDots')) scene.drawRect();
      }

      document.body.addEventListener('click', e => {
        if (e.target.type === 'button') {
          btn[e.target.name]();
        }
      });

      const mouseXY = e => {
        let r = canvas.getBoundingClientRect(e);
        return {
          x: e.clientX - Math.floor(r.left),
          y: e.clientY - Math.floor(r.top)
        };
      };


      const pixelXY = pos => ctx.getImageData(pos.x, pos.y, 1,1).data;

      const listenCanvas = () => {

        let mouse;
        let drag = undefined;
        let mouseOverCanvas = false;

        const updateXYRGB = () => {
          _('x').value = mouse.x;
          _('y').value = mouse.y;
         _('rgb').value = pixelXY(mouse);
        };


        canvas.addEventListener('click', e => {
          if (drag) {
            drag = undefined;
            scene.save();
          } else {
            scene.add(mouse);
            scene.save();
          } 

        });

        canvas.addEventListener('mousedown', () => {
          drag = scene.isDot(mouse) || scene.isLine(mouse);
        });

        canvas.addEventListener('mouseup', () => {

        });

        canvas.addEventListener('mousemove', e => {
          mouse = mouseXY(e);
          if (drag) {
            drag.elm[drag.method](mouse);
          } else {
            if (scene.isDot(mouse) || scene.isLine(mouse)) {
              canvas.style.cursor = 'pointer';
            } else {
              canvas.style.cursor = 'crosshair';
            };
          };
          updateXYRGB();
        });

        canvas.addEventListener('mouseover', () => {
          mouseOverCanvas = true;
        });

        canvas.addEventListener('mouseout', () => {
          mouseOverCanvas = false;
        });
    }

    </script>


  </body>
</html>